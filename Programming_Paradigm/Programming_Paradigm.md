### :warning: 혹시나 읽으시는 분께, 읽기 전에

제가 공부가 부족한 탓에, 프로그래밍 패러다임 관련 내용은 공부할수록 점점 더 어려워지는 것 같습니다.
(어쩌면 제가 제대로 이해하지 못하기 때문일지도 모르죠...)

하지만 더 좋은 프로그램을 설계하기 위해서는 반드시 알아야한다고 생각해서 정리해봤습니다.
해당 내용은 계속해서 수정될 것이고, 그 과정에서 제가 해당 개념을 제대로 이해할 수 있길 바랍니다..

# 명령형 프로그래밍

> 프로그램의 **상태**에 집중하여 프로그램을 작성하는 방식
> (프로그램을 작성할 때, 목표를 이루기 위한 과정을 한단계씩 나열하는 방식)



## 절차적 프로그래밍

> 일련의 처리 절차를 정해진 문법에 따라 순서대로 기술해나가는 방식
> 프로시저(루틴, 서브루틴, 메소드, 함수 등)을 이용한 프로그래밍 패러다임
> (수행되어야 할 연속적인 계산 과정을 포함)
>
> * 프로그램이 실행되는 절차를 중요시 함
> * 데이터를 중심으로 프로시저를 구현하며, 프로그램 전체가 유기적으로 연결
>
> ### 장점
>
> * 실행 속도가 빠름 - 컴퓨터의 처리구조와 유사
> * 재활용성이 높음 - 함수를 통해 코드를 다시 호출 가능
> * 모듈화 / 구조화가 용이함
>
> ### 단점
>
> * 프로그램을 분석하기 어렵다 (코드가 매우 긴 편)
> * 유지 보수나 코드의 수정이 어렵다 (각 코드가 순서에 민감하게 연결되어있음)



## 객체지향 프로그래밍(OOP)

> 프로그램을 여러 개의 독립된 **"객체"**들과 그 **객체들 간의 상호작용**으로 바라보는 것
> (프로시저보다는 속성(Attribute)과 행위(Method)로 구성된 **"객체"**를 중심으로 함)
>
> 1. 프로그램에 어떤 객체들이 필요할지 결정
> 2. 객체들의 속성과 행동을 결정
> 3. 객체들의 상호작용을 결정
>
> ### 장점
>
> * 코드의 재활용성이 높음 (상속, 다형성 등)
> * 모듈화를 통해 신뢰성 확보 / 추상화 가능 (생산성 향상)
> * 코드 설계 및 분석을 쉽게 할 수 있음 - 분석과 설계의 전환이 쉬움
> * 개발 및 유지보수가 용이함 / 객체 단위 분석 가능
>
> ### 단점
>
> * 구현 시 처리 시간이 지연됨 (객체들 간의 상호작용을 Message를 통함)
> * 설계에 많은 시간이 소요됨 + 테스트가 어려움
> * 모듈의 일부만 필요할 때 모듈 전체를 가져오게 된다면, 프로그램 사이즈가 커질 수 있음

### 추상화

* 상세한 정보는 무시하고 필요성에 의해 있어야할 정보들만 간추려서 구성함

* 데이터에서 공통의 속성이나 기능을 묶어서 이름을 붙이는 것 / 클래스를 정의하는 것

* 과정 추상화 / 데이터 추상화 / 제어 추상화

* **추상화 Tip**

    * **클래스의 이름, 변수, 메소드 이름 등을 그 의미가 잘 담기도록 지을 것!**

    * 클래스나 메소드의 정보를 기록할 것

        


### 캡슐화

1. 객체의 일부 구현 내용에 대한 외부로부터의 **직접적인 엑세스**를 차단하는 것

    객체의 속성, 메소드를 하나로 묶고, 실제 구현 내용을 외부에 감추는 것

2. 객체의 **속성**과 **그것을 사용하는 행동을 하나로 묶는 것**

    연관 있는 변수와 함수를 클래스로 묶는 것

* 외부에서 잘못된 접근 및 사용으로 인해 객체가 손상되는 것을 방지할 수 있음

    (자신의 연산을 통해야만 접근을 허용함)

* **사실 파이썬은 언어 차원에서 캡슐화를 지원 X**

    Java에서는 `private`이라는 키워드를 통해 외부의 접근을 완벽히 차단하지만,
    
    파이썬에서는 바뀐 새 이름으로 접근하는 것이 가능
    
    

### 상속

* 이미 정의된 상위 클래스의 속성과 행위를 하위 클래스가 모두 물려받는 것
* 부모 클래스를 재사용 가능 - 반복된 코드의 중복을 줄일 수 있음
* 유지 보수가 편리함 (부모 클래스만 한 번만 수정해도 됨)
* 객체의 다형성을 구현 가능



### 다형성

* 메시지를 통해 연산을 수행할 때, 같은 메시지에 대해 각기 다른 방식으로 연산할 수 있는 특성

* 부모클레스에서 물려받은 추상 클래스를 자식 클래스 내에서 오버라이딩 되어 사용되는 것

* 하나의 이름(방법)으로 다양한 상황에 대처하는 방법

* 예를 들어,

    여러 도형의 넓이를 구하는 cal_area라는 함수가 있을 때,

    사각형 클래스에서의 cal_area는 width * height로 계산하고,

    삼각형 클래스에서의 cal_area는 width * height / 2로 계산하는 방식



### SOLID 원칙

* **단일 책임 원칙 (Single Responsibility Principle)**
    
    * 클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.
    * 너무 많은 일을 수행하는 "God Object"를 만들지 말 것..
    * 보통 코드는 길어지지만, 클래스 당 길이는 짧아짐 (클래스의 의미를 파악하거나 수정하기 쉬움)
* **개방 폐쇄 원칙 (Open-Closed Principle)**
    
    * 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
    
    * 프로그램의 기존 기능을 확장할 수 있다 + 한 번 작성한 코드를 바꾸지 않아도 된다.
    
        (코드를 수정하지 않아도 기존 기능을 확장할 수 있어야 한다.)
* **리스코프 치환 원칙 (Liskov Substitution Principle)**
    
    * 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
    * 자식 클래스에서 변수나 메소드를 오버라이딩할 경우 주의해야 됨!
        1. 자식 클래스가 부모 클래스의 변수 타입을 바꾸거나
            메소드의 파라미터 또는 리턴값의 타입 or 개수를 바꾸는 경우
        2. 자식 클래스가 부모 클래스의 **의도와 다르게** 메소드를 오버라이딩 하는 경우
* **인터페이스 분리 원칙 (Interface Segregation Principle)**
    
    * 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
    * 클래스가 사용하지 않을 메소드에 의존할 것을 강요하지 말 것!!
* **의존 관계 역전 원칙 (Dependency Inversion Principle)**
    
    * 고수준 모듈(상위 모듈)은 저수준 모듈(하위 모듈)의 구현에 의존해서는 안된다.



# 선언형 프로그래밍

> 과정보다는 무엇을 목표로하는지를 설명
> ("어떻게"에 해당하는 방식을 나타내는 부분이 추상화 되어있어야 제대로 작동)
>
> * 프로그램이 수행해야하는 목표를 명시하면 컴퓨터가 알아서 해결함
> * SQL, HTML, CSS - 세부적인 내용은 추상화되어있고, 무엇을 달성하는지에 집중
>
> ### 장점
>
> * 가독성이나 재사용성이 우수함
> * 프로그램 동작을 변경하지 않고도 값을 변경 가능



# 함수형 프로그래밍

> 함수를 먼저 작성하고, 함수에 맞는 데이터를 세팅하는 방식
>
> 컴퓨터 성능의 향상으로 객체들 간의 상호작용이 순서대로 작동하는 거이 아닌, 동시에 이루어지는 것이 가능
>
> ### 장점
>
> * Side Effect를 방지 가능 / 객체지향보다 코드가 간결함