# 알고리즘

> 어떠한 문제를 해결하기 위한 절차나 방법
>





## 재귀 함수

> 함수 안에서 자기 자신을 호출하여 작업을 수행하는 방식의 함수
> 반복문을 사용하는 코드를 재귀함수로 구현하는 것이 가능하며, 그 반대도 가능함
> 
> 함수 내에서 다시 자기 자신을 호출한 뒤 끝날때까지 뒷부분의 명령문이 수행X
> (종료조건이 반드시 있어야 무한루프가 안 됨)



* 카운트다운 재귀함수

```python
def count_down(num):
    if num >= 1:
        print(num)
        count_down(num-1)
    else:
        print('The End')

count_down(5)
```

```bash
5
4
3
2
1
The End
```



* 덧셈 재귀함수

```python
def mysum(num):
    if num > 1:
        return num + mysum(num-1)
    else:
        return 1

print(mysum(10))
```

```bash
55
```



* 팩토리얼 재귀함수

```python
def fact(num):
    if num > 1:
        return num * fact(num-1)
    else:
        return 1

print(fact(5))
```

```bash
120
```



* 피보나치수열 재귀함수

```python
def fibo(num):
    if num == 1 or num == 2:
        return 1
    else:
        return fibo(num-1) + fibo(num-2)

print(fibo(10))
```

```bash
55
```







## 정렬 알고리즘



### 1. 버블 정렬

> 인접한 두 값을 검사하여 정렬, 시간은 오래 걸리지만 코드가 단순함
> (정렬되는 과정이 거품이 수면으로 올라오는 듯한 모습)

* 간단한 버블 정렬의 예시

```python
num_list = [4, 3, 1, 2]
for i in range(len(num_list)):
    for j in range(len(num_list)-1-i):
        if num_list[j] > num_list[j+1]:
            num_list[j], num_list[j+1] = num_list[j+1], num_list[j]
            print('i = {0}, j = {1}, num_list = {2}'.format(i, j, num_list))
```

```bash
i = 0, j = 0, num_list = [3, 4, 1, 2]
i = 0, j = 1, num_list = [3, 1, 4, 2]
i = 0, j = 2, num_list = [3, 1, 2, 4]
i = 1, j = 0, num_list = [1, 3, 2, 4]
i = 1, j = 1, num_list = [1, 2, 3, 4]
```

​			`=>` 한 바퀴 돌 때 가장 큰 값이 맨 뒤에 저장 된다.

* 버블 정렬 예시 2

```python
a = [7, 4, 3, 2, 5, 4]

for i in range(len(a)-1, 0, -1): # 구간 끝 감소
    for j in range(0, i): # 오른쪽 원소가 존재하는 범위
        if a[j] > a[j+1]:
            a[j], a[j+1] = a[j+1], a[j]
            print('i = {0}, j = {1}, a = {2}'.format(i, j, a))

print(a)
```

```bash
i = 5, j = 0, a = [4, 7, 3, 2, 5, 4]
i = 5, j = 1, a = [4, 3, 7, 2, 5, 4]
i = 5, j = 2, a = [4, 3, 2, 7, 5, 4]
i = 5, j = 3, a = [4, 3, 2, 5, 7, 4]
i = 5, j = 4, a = [4, 3, 2, 5, 4, 7]
i = 4, j = 0, a = [3, 4, 2, 5, 4, 7]
i = 4, j = 1, a = [3, 2, 4, 5, 4, 7]
i = 4, j = 3, a = [3, 2, 4, 4, 5, 7]
i = 3, j = 0, a = [2, 3, 4, 4, 5, 7]
```



* 재귀 함수를 이용한 버블 정렬

```python
def bubble_sort(n=0, i=0):
    global num_list
    if i == len(num_list) - 1:
        return
    else:
        if n < len(num_list) - 1:
            if num_list[n] > num_list[n+1]:
                num_list[n], num_list[n+1] = num_list[n+1], num_list[n]
            bubble_sort(n+1, i)
        else:
            bubble_sort(0, i+1)

num_list = [4, 2, 3, 5, 1]
bubble_sort()
print(num_list)
```

```bash
[1, 2, 3, 4, 5]
```



### 2.삽입 정렬

> 앞의 숫자들을 정렬된 상태라고 가정하고,
> 정렬되지 않은 숫자들을 정렬된 숫자 사이에 삽입하며 정렬하는 방법

* 간단한 삽입 정렬의 예시

```python
num_list = [4,1,5,2,3]
for i in range(1, len(num_list)):
    for j in range(i):
        if num_list[i] < num_list[j]:
            num_list.insert(j, num_list.pop(i))
        print('i = {0}, j = {1}, num_list = {2}'.format(i, j, num_list))
```

```bash
i = 1, j = 0, num_list = [1, 4, 5, 2, 3]
i = 2, j = 0, num_list = [1, 4, 5, 2, 3]
i = 2, j = 1, num_list = [1, 4, 5, 2, 3]
i = 3, j = 0, num_list = [1, 4, 5, 2, 3]
i = 3, j = 1, num_list = [1, 2, 4, 5, 3]
i = 3, j = 2, num_list = [1, 2, 4, 5, 3]
i = 4, j = 0, num_list = [1, 2, 4, 5, 3]
i = 4, j = 1, num_list = [1, 2, 4, 5, 3]
i = 4, j = 2, num_list = [1, 2, 3, 4, 5]
i = 4, j = 3, num_list = [1, 2, 3, 4, 5]
```

* 재귀 함수를 이용한 삽입 정렬

```python
def Insertion_Sort(i = 0, j = 0):
    global num_list
    if j == len(num_list):
        return
    else:
        if i == j:
            Insertion_Sort(0, j+1)
        else:
            if num_list[i] > num_list[j]:
                num_list.insert(i, num_list.pop(j))
            Insertion_Sort(i+1, j)

num_list = [4, 2, 5, 1, 3]
Insertion_Sort()
print(num_list)
```

```bash
[1, 2, 3, 4, 5]
```



### 3. 카운팅 정렬(Counting Sort)

> 각 항목이 몇 개씩 있는지 세고, 그를 정렬하는 방식
>
> 충분한 공간을 할당하기 위해 집합 내의 가장 큰 정수를 알아야 함

* 카운팅 정렬의 예시

  ​		num_list = [0, 4, 1, 3, 1, 2, 4, 1]

1. Data에서 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 리스트에 저장

   Counts = [1, 3, 1, 1, 2]
   
2. 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 Counts의 원소를 조정

   Counts = [1, 4, 5, 6, 8] / 해당 원소가 정렬될 때 리스트 몇번쨰 위치에 있을 지 표시

3. Counts[1]을 감소시키고 Temp에 1을 삽입

```bash
def Counting_Sort(A, B, k):
# A [1 .. n] -- 입력리스트 사용된 숫자(1~k)
# B [1 .. n] -- 정렬된 리스트
# C [1 .. n] -- 카운트 리스트
    C = [0] * k
    for i in range(0, len(B)):
    	C[A[i]] += 1
    for i in range(1, len(C)):
    	C[i] += C[i-1]
    for i in range(len(B)-1, -1, -1):
    	B[C[A[i]]-1] = A[i]
    	C[A[i]] -= 1
    
a = [0, 4, 1, 3, 1, 2, 4 ,1]
b = [0] * len(a)
Counting_Sort(a, b, 5)
print(b)
```



### 4. 선택 정렬 (Selection Sort)

#### 4.1 셀렉션 알고리즘

> 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법
> 
>1. 정렬 알고리즘을 이용하여 자료를 정렬
> 2. 원하는 순서에 있는 원소 가져오기

k번째로 작은 원소를 찾는 알고리즘

> 1번부터 k번째까지 작은 원소들을 찾아 List의 앞쪽으로 이동시키고, List의 k번째를 반환

```python
def select(list, k):
    for i in range(0, k):
        min_idx = i
        for j in range(i+1, len(list)):
            if list[min_idx] > list[j]:
                min_idx = j
        list[i], list[min_idx] = list[min_idx], list[i]
    return list[k-1]

test = [1, 5, 4, 3, 2]
k = 4
print('num_list에서 {0}번째로 작은 숫자는 {1}입니다.'.format(k, select(test, k)))
```

```bash
num_list에서 4번째로 작은 숫자는 4입니다.
```



#### 4.2 선택 정렬 - 셀렉션 알고리즘을 전체 자료에 적용

> 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
> 
>1. 주어진 List 중 최소값을 찾음
> 2. 그 값을 List의 맨 앞에 위치한 값과 교환
> 3. 맨 처음 위치를 제외한 나머지 List를 대상으로 위의 과정을 반복
> 

```bash
def Selection_Sort(num_list):
    for i in range(0, len(num_list)-1):
        min_idx = i
        for j in range(i+1, len(num_list)):
            if num_list[min_idx] > num_list[j]:
                min_idx = j
        num_list[i], num_list[min_idx] = num_list[min_idx], num_list[i]
    return num_list
        
num_list = [1, 5, 4, 3, 2]
print(Selection_Sort(num_list))
```

```bash
[1, 2, 3, 4, 5]
```





## 탐색 알고리즘

### 1. 순차 탐색

> 찾고자하는 값을 데이터 배열의 첫 번째부터 하나씩 탐색하는 방법
> List, 연결 List 등 순차적으로 구현된 자료구조에서 유용함
> 데이터 별도로 조작할 필요가 없음

```python
num_list = [1,2,3,4,5]
num = 2
res = False # 기본은 False
for i in num_list: # num_list 내의 항목에 대해서
    if i == num: # 항목이 num과 일치하면
        res = True # res에 True
        break # 찾는 즉시 반복문에서 나감
print(res) # 끝까지 못 찾으면 기본 값 False 출력
```

* 정렬되지 않은 자료의 검색 과정
  1. 첫 원소부터 순서대로 검색대상과 키 값이 같은 원소가 있는지 비교하며 찾음
  2. 키 값이 동일한 원소를 찾으면 그 원소의 인덱스를 반환
  3. 자료구조의 마지막까지 검색 대상을 찾지 못하면 검색 실패

* 정렬된 자료의 검색 과정
  1. 자료가 오름차순으로 정렬된 상태에서 검색을 실시
  2. 자료를 순차적으로 검색하면서 키 값을 비교함
  3. 원소의 키 값이 검색 대상의 키 값보다 크면 원소가 없다는 것이므로 더이상 검색하지 않고 검색을 종료함



### 2. 이진 탐색

> 비교할 때마다 데이터의 양이 반씩 줄음 / 데이터가 정렬된 상태여야 됨
> 자료의 가운데 항목의 키 값과 비교하여 다음 검색의 위치를 결정, 검색
>
> 1. 자료의 중앙에 있는 원소 선택
>
> 2. 중앙 원소의 값과 찾고자 하는 목표 값을 비교
>
> 3. 목표값 < 중앙 원소 값 : 자료의 왼쪽 반에 대해서 새로 검색을 수행
>
>    목표값 > 중앙 원소 값 : 자료의 오른쪽 반에 대해서 새로 검색을 수행
>
> 4. 찾고자 하는 값을 찾을 때까지 반복
>
> * 삽입이나 삭제를 했을 때 List의 상태를 항상 정렬 상태로 유지해야 됨

* 간단한 이진 탐색의 예시

```python
def binarySearch(a, key):
    start = 0
    end = len(a) - 1
    while start <= end:
        middle = start + (end - start) // 2 # 중앙 원소 값
        if key == a[middle]: # 검색 성공
            return True
        elif key < a[middle]: # 목표값이 중앙 원소 값보다 작은 경우
            end = middle -1 # 끝을 중앙값 - 1 / 항목의 왼쪽 반
        else: # 큰 경우
            start = middle +1 # 시간을 중앙 값 + 1 # 항목의 오른쪽 반
    return False

num_list = [1, 2, 3, 4, 5, 9, 11, 17, 20]
key = 9
print(binarySearch(num_list, key)) # True
```

* 재귀 함수를 이용한 이진 탐색 1

```python
def binarySearch2(a, key, low, high):
    if low > high : # 검색 실패
        return False
    else:
        middle = (low + high) // 2
        if key == a[middle]: # 검색 성공
            return True
        elif key < a[middle]:
            return binarySearch2(a, key, low, middle-1)
        elif a[middle] < key:
            return binarySearch2(a, key, middle+1, high)

num_list = [1, 2, 3, 4, 5, 9, 11, 17, 20]
key = 9
print(binarySearch2(num_list, key, 0, len(num_list))) # True
```

* 재귀 함수를 이용한 이진 탐색 2

```python
def binary_search3(data, number = 0):
    mid = int(len(data)/2) # num_list의 중간 값
    if len(data)>1: # 처음 data의 길이가 1이상인지 (data list 안의 값이 2개 이상 인지)
        if data[mid] > number: # 목표 값이 중간 값보다 작은 경우
            binary_search3(data[:mid],number) # 중간 값의 앞 부분
        elif data[mid] < number: # 목표 값이 중간 값보다 큰 경우
            binary_search3(data[mid:],number) # 중간 값의 뒷 부분
        else:
            print("True")
    else: # data_list의 개수가 1개 이하이면 하나 남은 값과 ㅊ자는 값을 비교
        print(data[0]==number)

num_list = [1, 2, 3, 4, 5, 9, 11, 17, 20]
binary_search3(num_list, 9) # True
```





## 패턴 매칭

> 본문에서 특정한 문자열을 찾는 것



### 1. 고지식한 패턴 검색 알고리즘(Brute Force)

> 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교
>
> 1. 비교할 패턴과 원본 모두 첫 문자열부터 시작
>2. 일치하지 않을 경우 패턴 매칭 실패
> 3. 원본의 인덱스는 다음 시작점으로 이동, 패턴의 인덱스는 원점으로 돌아감

```python
p = 'is' # 찾을 패턴
t = 'This is a book~!' # 전체 텍스트
M = len(p) # 찾을 패턴의 길이
N = len(t) # 전체 텍스트의 길이

def BruteForec(p, t):
    i = 0 # t의 인덱스
    j = 0 # p의 인덱스
    while j < M and i < N:
        if t[i] != p[j]:
            i = i-j
            j = -1
        i += 1
        j += 1
    if j == M : return i-M # 검색 성공
    else: return -1 # 검색 실패
```



### 2. KMP 알고리즘

> 불일치가 발생한 앞 부분에 대해서는 다시 비교하지 않고 매칭을 수행
>
> 1. 패턴을 전처리하여 배열 next[M]을 구해서 잘못된 시작을 최소화함
>
>    next[M] : 불일치가 발생했을 경우 이동할 다음 위치
>
> 
>(패턴의 각 위치에 대해 매칭에 실패했을 때 돌아갈 곳을 준비해 둠)



### 3. 보이어-무어 알고리즘

> 오른쪽에서 왼쪽으로 비교, 
> 
> 패턴의 오른쪽 끝에 있는 문자가 불일치하고, 이 문자가 패턴 내에 존재하지 않는 경우
> 패턴의 길이 만큼 이동함
>
> 오른쪽 끝에 있는 문자가 불일치하고, 이 문자가 패턴 내에 존재할 경우
> 패턴에서 일치하는 문자를 찾아서 위치를 맞추어 줌

* 보이어-무어 알고리즘을 통한 패턴 탐색 예시

  `'a pattern matching algorithm'` 에서 `'rithm'`을 찾을 경우

  `rithm String`의 `skip`배열

|  m   |  h   |  t   |  i   |  r   | 다른 모든 문자 |
| :--: | :--: | :--: | :--: | :--: | :------------: |
|  0   |  1   |  2   |  3   |  4   |       5        |

		1. 'a pat' 5문자 -> 마지막 문자열이 t이므로 2칸 점프
​		2. 'patte' 5문자 -> 마지막 문자열이 e이므로 5칸 점프
​		3. 'rn ma' 5문자 -> 마지막 문자열이 a이므로 5칸 점프
​		... 'rithm' 5문자 -> 마지막 문자열과 패턴이 일치, 내부 문자열들 비교







## 완전 탐색

> 완전 검색 : 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
>
> * 모든 경우의 수를 테스트한 후, 최종 해법을 도출
>
> * 모든 경우의 수를 생성, 테스트하기 때문에 수행 속도는 느리지만 해답을 찾지 못할 확률이 적음
>

* Baby-Gin 게임 / 부분집합 문제 등 확인



#### 순열 : 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것

* {1, 2, 3}을 사용해서 모든 순열을 프린트하는 경우

```bash
for i1 in range(1, 4):
    for i2 in range(1, 4):
        if i2 != i1:
            for i3 in range(1, 4):
                if i3 != i1 and i3 != i2:
                    print(i1, i2, i3)
```

```bash
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```







## 탐욕 알고리즘 (그리디 알고리즘)

> 최적 해를 구하기 위해 사용하는 근시안적인 방법
> 순간순간 가장 최적이라고 생각하는 것을 선택하는 방식
> 
> ※ 최적의 선택을 반복한 결과가 최적의 결과인 것은 보장할 수 없음
> ​	Ex) test = {7 : [30, 100], 13 : [5, 11]} 에서 가장 큰 값을 고를 때
> ​		최적의 결과는 7 + 100 이지만, 탐욕 알고리즘은 13 + 11이 됨
>
> 선택이 다음 선택과 전혀 무관한 값이고, 매 순간의 최적해가 문제에 대한 최적해인 경우 효과적

수행 과정

1. 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분 해 집합에 추가
2. 실행 가능성 검사 : 새로운 부분 해 집합이 실행 가능한지를 확인 (문제의 제약 조건을 위반하지 않는지 검사)
3. 해 검사 : 새로운 부분 해 집합이 문제의 해가 되는지 확인, 아직 전체 문제의 해가 완성 X이면 해 선택부터 다시



#### 탐욕 알고리즘 적용 예시 - 동전 지불

해 선택 : 가장 단위가 큰 동전을 하나 골라 거스름돈에 추가
실행 가능성 검사 : 거스름돈이 손님에게 줘야할 액수를 초과하는 지 확인
​		초과한다면 마지막 동전을 빼고 해 선택으로 돌아가서 현재보다 한 단계 작은 단위의 동전을 추가
해 검사 : 거스름돈이 일치하는 지 확인, 모자라면 다시 해 선택으로 가서 반복



* 372원을 주려고 할 때, 1원, 10원, 50원, 100원 동전으로 주는 방법

```python
coins = [100, 50, 10, 1]
value = 362
dic = {}

for i in coins: # 각 동전의 크기를 key 값, value를 0으로 초기화
    dic[i] = 0

while value != 0:
    for coin in coins:
        if coin <= value:
            dic[coin] += 1
            value -= coin
            break

for key, val in dic.items():
    print('{0}원 동전 : {1}개'.format(key, val))
```

```bash
100원 동전 : 3개
50원 동전 : 1개
10원 동전 : 1개
1원 동전 : 2개
```





## 최단거리 알고리즘

> 한 지점에서 다른 지점까지의 최단거리 구하기
> 가장 적은 비용으로 해답에 도달하는 경로를 찾아내는 대부분의 문제
> ex. 네비게이션, 큐브 풀기, 미로탐색 등
