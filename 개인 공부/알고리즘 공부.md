# 알고리즘

> 어떠한 문제를 해결하기 위한 절차나 방법
>





## 재귀 함수

> 함수 안에서 자기 자신을 호출하여 작업을 수행하는 방식의 함수
> 반복문을 사용하는 코드를 재귀함수로 구현하는 것이 가능하며, 그 반대도 가능함
> 
> 함수 내에서 다시 자기 자신을 호출한 뒤 끝날때까지 뒷부분의 명령문이 수행X
> (종료조건이 반드시 있어야 무한루프가 안 됨)



* 카운트다운 재귀함수

```python
def count_down(num):
    if num >= 1:
        print(num)
        count_down(num-1)
    else:
        print('The End')

count_down(5)
```

```bash
5
4
3
2
1
The End
```



* 덧셈 재귀함수

```python
def mysum(num):
    if num > 1:
        return num + mysum(num-1)
    else:
        return 1

print(mysum(10))
```

```bash
55
```



* 팩토리얼 재귀함수

```python
def fact(num):
    if num > 1:
        return num * fact(num-1)
    else:
        return 1

print(fact(5))
```

```bash
120
```



* 피보나치수열 재귀함수

```python
def fibo(num):
    if num == 1 or num == 2:
        return 1
    else:
        return fibo(num-1) + fibo(num-2)

print(fibo(10))
```

```bash
55
```







## 정렬 알고리즘



### 1. 버블 정렬

> 인접한 두 값을 검사하여 정렬, 시간은 오래 걸리지만 코드가 단순함
> (정렬되는 과정이 거품이 수면으로 올라오는 듯한 모습)

* 간단한 버블 정렬의 예시

```python
num_list = [4, 3, 1, 2]
for i in range(len(num_list)):
    for j in range(len(num_list)-1-i):
        if num_list[j] > num_list[j+1]:
            num_list[j], num_list[j+1] = num_list[j+1], num_list[j]
            print('i = {0}, j = {1}, num_list = {2}'.format(i, j, num_list))
```

```bash
i = 0, j = 0, num_list = [3, 4, 1, 2] # 0번과 1번 비교 -> 교체
i = 0, j = 1, num_list = [3, 1, 4, 2] # 1번과 2번 비교 -> 교체
i = 0, j = 2, num_list = [3, 1, 2, 4] # 2번과 3번 비교 -> 교체
i = 1, j = 0, num_list = [1, 3, 2, 4] # 0번과 1번 비교 -> 교체
i = 1, j = 1, num_list = [1, 2, 3, 4] # 1번과 2번 비교 -> 교체
```

​			`=>` 한 바퀴 돌 때 가장 큰 값이 맨 뒤에 저장 된다.

* 버블 정렬 예시 2

```python
a = [7, 4, 3, 2, 5, 4]

for i in range(len(a)-1, 0, -1): # 구간 끝 감소
    for j in range(0, i): # 오른쪽 원소가 존재하는 범위
        if a[j] > a[j+1]:
            a[j], a[j+1] = a[j+1], a[j]
        print('i = {0}, j = {1}, a = {2}'.format(i, j, a))

print(a)
```

* i는 몇번째 위치까지 비교할 것인가, j는 몇번과 몇번을 비교할 것인가와 관련 있음

```bash
처음 : a = [7, 4, 3, 2, 5, 4] #j번과 j+1번 비교, i는 몇번까지 비교할 것인가.
i = 5, j = 0, a = [4, 7, 3, 2, 5, 4] # 0번과 1번 비교 -> 교체
i = 5, j = 1, a = [4, 3, 7, 2, 5, 4] # 1번과 2번 비교 -> 교체
i = 5, j = 2, a = [4, 3, 2, 7, 5, 4] # 2번과 3번 비교 -> 교체
i = 5, j = 3, a = [4, 3, 2, 5, 7, 4] # 3번과 4번 비교 -> 교체
i = 5, j = 4, a = [4, 3, 2, 5, 4, 7] # 4번과 5번 비교 -> 교체 / 최댓값(7)이 가장 오른쪽
i = 4, j = 0, a = [3, 4, 2, 5, 4, 7] # 비교시작, 마지막 7은 이제부터 비교 X, 0번과 1번
i = 4, j = 1, a = [3, 2, 4, 5, 4, 7] # 1번과 2번 비교 -> 교체
i = 4, j = 2, a = [3, 2, 4, 5, 4, 7] # 2번과 3번 비교 -> 교체 안 됨
i = 4, j = 3, a = [3, 2, 4, 4, 5, 7] # 3번과 4번 비교 -> 교체
i = 3, j = 0, a = [2, 3, 4, 4, 5, 7] # 비교시작, 마지막 5는 이제부터 비교 X, 0번과 1번
i = 3, j = 1, a = [2, 3, 4, 4, 5, 7] # 1번과 2번 비교 -> 교체 안 됨
i = 3, j = 2, a = [2, 3, 4, 4, 5, 7] # 2번, 3번 비교 -> 교체 안됨
i = 2, j = 0, a = [2, 3, 4, 4, 5, 7] # 비교 시작, 마지막 4는 이제부터 비교 X
i = 2, j = 1, a = [2, 3, 4, 4, 5, 7]
i = 1, j = 0, a = [2, 3, 4, 4, 5, 7] # 비교 시작, 마지막 4는 이제부터 비교 X
```



* 재귀 함수를 이용한 버블 정렬

```python
def bubble_sort(n=0, i=0):
    global num_list
    if i == len(num_list) - 1:
        return
    else:
        if n < len(num_list) - 1:
            if num_list[n] > num_list[n+1]:
                num_list[n], num_list[n+1] = num_list[n+1], num_list[n]
            bubble_sort(n+1, i)
        else:
            bubble_sort(0, i+1)

num_list = [4, 2, 3, 5, 1]
bubble_sort()
print(num_list)
```

```bash
[1, 2, 3, 4, 5]
```



### 2.삽입 정렬

> 앞의 숫자들을 정렬된 상태라고 가정하고,
> 정렬되지 않은 숫자들을 정렬된 숫자 사이에 삽입하며 정렬하는 방법

* 삽입 정렬 알고리즘

```python
def find_ins_idx(r, v): # list r에서 v가 들어가야할 위치 찾기
    for i in range(0, len(r)): # 정렬된 리스트 r의 자료를 앞에서부터 확인
        if v < r[i]: # v보다 i번째 위치의 값이 크면 v가 그 값 바로 앞에 놓여야 됨
            return i
    return len(r) # 위치를 못 찾았으면, r의 모든 원소보다 v가 큼 (가장 마지막에 들어감)

def ins_sort(a):
    result = [] # 정렬된 값 저장
    while a: # 기존 리스트에 값이 있으면 반복
        value = a.pop(0) # 기존 리스트에서 꺼냄
        ins_idx = find_ins_idx(result, value) # 꺼낸 값이 들어갈 위치 찾기
        result.insert(ins_idx, value) # 찾은 위치에 값 삽입 (이후 값이 한 칸 씩 밀림)
        print('정렬할 값 : {0}, 들어갈 위치 인덱스 : {1}\n정렬된 리스트 : {2}'.format(value, ins_idx, result))
    return result

d = [2, 4, 5, 1, 3]
print(ins_sort(d))
```

```bash
정렬할 값 : 2, 들어갈 위치 인덱스 : 0
정렬된 리스트 : [2]
정렬할 값 : 4, 들어갈 위치 인덱스 : 1
정렬된 리스트 : [2, 4]
정렬할 값 : 5, 들어갈 위치 인덱스 : 2
정렬된 리스트 : [2, 4, 5]
정렬할 값 : 1, 들어갈 위치 인덱스 : 0
정렬된 리스트 : [1, 2, 4, 5]
정렬할 값 : 3, 들어갈 위치 인덱스 : 2
정렬된 리스트 : [1, 2, 3, 4, 5]
```



* 간단한 삽입 정렬의 예시

```python
num_list = [4,1,5,2,3]
for i in range(1, len(num_list)):
    for j in range(i):
        if num_list[i] < num_list[j]:
            num_list.insert(j, num_list.pop(i))
        print('i = {0}, j = {1}, num_list = {2}'.format(i, j, num_list))
```

```bash
i = 1, j = 0, num_list = [1, 4, 5, 2, 3]
i = 2, j = 0, num_list = [1, 4, 5, 2, 3]
i = 2, j = 1, num_list = [1, 4, 5, 2, 3]
i = 3, j = 0, num_list = [1, 4, 5, 2, 3]
i = 3, j = 1, num_list = [1, 2, 4, 5, 3]
i = 3, j = 2, num_list = [1, 2, 4, 5, 3]
i = 4, j = 0, num_list = [1, 2, 4, 5, 3]
i = 4, j = 1, num_list = [1, 2, 4, 5, 3]
i = 4, j = 2, num_list = [1, 2, 3, 4, 5]
i = 4, j = 3, num_list = [1, 2, 3, 4, 5]
```

* 재귀 함수를 이용한 삽입 정렬

```python
def Insertion_Sort(i = 0, j = 0):
    global num_list
    if j == len(num_list):
        return
    else:
        if i == j:
            Insertion_Sort(0, j+1)
        else:
            if num_list[i] > num_list[j]:
                num_list.insert(i, num_list.pop(j))
            Insertion_Sort(i+1, j)

num_list = [4, 2, 5, 1, 3]
Insertion_Sort()
print(num_list)
```

```bash
[1, 2, 3, 4, 5]
```



### 3. 카운팅 정렬(Counting Sort)

> 각 항목이 몇 개씩 있는지 세고, 그를 정렬하는 방식
>
> 충분한 공간을 할당하기 위해 집합 내의 가장 큰 정수를 알아야 함

* 카운팅 정렬의 예시

  ​		num_list = [0, 4, 1, 3, 1, 2, 4, 1]

1. Data에서 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 리스트에 저장

   Counts = [1, 3, 1, 1, 2]
   
2. 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 Counts의 원소를 조정

   Counts = [1, 4, 5, 6, 8] / 해당 원소가 정렬될 때 리스트 몇번째 위치에 있을 지 표시

3. Counts[1]을 감소시키고 Temp에 1을 삽입

```bash
def Counting_Sort(A, B, k):
# A [1 .. n] -- 입력리스트 사용된 숫자(1~k)
# B [1 .. n] -- 정렬된 리스트
# C [1 .. n] -- 카운트 리스트
    C = [0] * k
    for i in range(0, len(B)):
    	C[A[i]] += 1
    for i in range(1, len(C)):
    	C[i] += C[i-1]
    for i in range(len(B)-1, -1, -1):
    	B[C[A[i]]-1] = A[i]
    	C[A[i]] -= 1
    
a = [0, 4, 1, 3, 1, 2, 4 ,1]
b = [0] * len(a)
Counting_Sort(a, b, 5)
print(b)
```

```python
a = [0, 4, 1, 3, 1, 2, 4, 1]
b = [0] * len(a)

count = [0] * (max(a) + 1)
for i in range(0, len(b)):
    count[a[i]] += 1                  # 현재 count = [1, 3, 1, 1, 2]
for i in range(1, len(count)):
    count[i] += count[i - 1]              # 현재 count = [1, 4, 5, 6, 8]
for i in range(len(b) - 1, -1, -1): # i는 a의 마지막부터 불러오는 역할
    b[count[a[i]] - 1] = a[i]
    count[a[i]] -= 1
    print('인덱스 {} => {} / count[{}]의 값(count의 {}번째 값)을 1개 감소 =>\ncount = {}입니다.\n현재 정렬된 리스트는 {}입니다.'.format(i, a[i], a[i], a[i]+1, count, b))
    print()
```

* 카운트 함수를 통해 정렬될 위치를 할당하고, 할당된 위치의 맨 뒤부터 숫자를 채움.

```bash
인덱스 7 => 1 / count[1]의 값(count의 2번째 값)을 1개 감소 =>
count = [1, 3, 5, 6, 8]입니다. # 만약 다음에 1이 나오면 3번 위치에 들어갈 것
현재 정렬된 리스트는 [0, 0, 0, 1, 0, 0, 0, 0]입니다.
# 다음에 0이 나온다면 1
# 다음에 1이 나온다면 3
# 다음에 2가 나온다면 5
# 다음에 3이 나온다면 6
# 다음에 4가 나온다면 8 번째 위치에 들어갈 것

인덱스 6 => 4 / count[4]의 값(count의 5번째 값)을 1개 감소 =>
count = [1, 3, 5, 6, 7]입니다. # 만약 다음에 4가 나오면 7번 위치에 들어갈 것.
현재 정렬된 리스트는 [0, 0, 0, 1, 0, 0, 0, 4]입니다.

인덱스 5 => 2 / count[2]의 값(count의 3번째 값)을 1개 감소 =>
count = [1, 3, 4, 6, 7]입니다. # 다음에 2가 나온다면 4번째에 나오겠지만, 2는 없음
현재 정렬된 리스트는 [0, 0, 0, 1, 2, 0, 0, 4]입니다.

인덱스 4 => 1 / count[1]의 값(count의 2번째 값)을 1개 감소 =>
count = [1, 2, 4, 6, 7]입니다.
현재 정렬된 리스트는 [0, 0, 1, 1, 2, 0, 0, 4]입니다.

인덱스 3 => 3 / count[3]의 값(count의 4번째 값)을 1개 감소 =>
count = [1, 2, 4, 5, 7]입니다.
현재 정렬된 리스트는 [0, 0, 1, 1, 2, 3, 0, 4]입니다.

인덱스 2 => 1 / count[1]의 값(count의 2번째 값)을 1개 감소 =>
count = [1, 1, 4, 5, 7]입니다.
현재 정렬된 리스트는 [0, 1, 1, 1, 2, 3, 0, 4]입니다.

인덱스 1 => 4 / count[4]의 값(count의 5번째 값)을 1개 감소 =>
count = [1, 1, 4, 5, 6]입니다.
현재 정렬된 리스트는 [0, 1, 1, 1, 2, 3, 4, 4]입니다.

인덱스 0 => 0 / count[0]의 값(count의 1번째 값)을 1개 감소 =>
count = [0, 1, 4, 5, 6]입니다.
현재 정렬된 리스트는 [0, 1, 1, 1, 2, 3, 4, 4]입니다.
```



### 4. 선택 정렬 (Selection Sort)

#### 4.1 셀렉션 알고리즘

> 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법
> 
>1. 정렬 알고리즘을 이용하여 자료를 정렬
> 2. 원하는 순서에 있는 원소 가져오기

k번째로 작은 원소를 찾는 알고리즘

> 1번부터 k번째까지 작은 원소들을 찾아 List의 앞쪽으로 이동시키고, List의 k번째를 반환

```python
def select(list, k):
    for i in range(0, k):
        min_idx = i
        for j in range(i+1, len(list)):
            if list[min_idx] > list[j]:
                min_idx = j
        list[i], list[min_idx] = list[min_idx], list[i]
    return list[k-1]

test = [1, 5, 4, 3, 2]
k = 4
print('num_list에서 {0}번째로 작은 숫자는 {1}입니다.'.format(k, select(test, k)))
```

```bash
num_list에서 4번째로 작은 숫자는 4입니다.
```



#### 4.2 선택 정렬 - 셀렉션 알고리즘을 전체 자료에 적용

> 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
> 
>1. 주어진 List 중 최소값을 찾음
> 2. 그 값을 List의 맨 앞에 위치한 값과 교환
> 3. 맨 처음 위치를 제외한 나머지 List를 대상으로 위의 과정을 반복
> 

```bash
def Selection_Sort(num_list):
    for i in range(0, len(num_list)-1):
        min_idx = i
        for j in range(i+1, len(num_list)):
            if num_list[min_idx] > num_list[j]:
                min_idx = j
        num_list[i], num_list[min_idx] = num_list[min_idx], num_list[i]
    return num_list
        
num_list = [1, 5, 4, 3, 2]
print(Selection_Sort(num_list))
```

```bash
[1, 2, 3, 4, 5]
```



### 5. 병합 정렬 - 조금 더 공부 필요

> 1. 10개의 숫자가 있을 때 그를 2개의 집합으로 나누어서 정렬시킴
> 2. 두 집합 중 더 작은 수를 빈 리스트에 추가하는 것을 반복함

```python
def merge_sort(a):
    n = len(a)
    if n <= 1: # 종료조건, 정렬할 리스트의 자료 개수가 1개 이하이면 정렬할 필요 없음
        return a
    # 그룹을 나누어 각각 병합 정렬을 호출하는 과정
    mid = n //2 # 중간을 기준으로 2개로 나눔
    g1 = merge_sort(a[:mid]) # 재귀 호출, 첫 번째 그룹
    g2 = merge_sort(a[mid:]) # 재귀 호출, 두 번째 그룹
    # 이제부터 2개의 그룹을 1개로 병합하기 시작
    result = []
    while g1 and g2: # g1과 g2에 모두 자료가 남아있을 때
        if g1[0] < g2[0]: # 두 그룹의 맨 앞 위치 비교
            result.append(g1.pop(0))
        else:
            result.append(g2.pop(0))
        # 아직 남은 자료들이 다시 추가되어 반복
    while g1:
        result.append(g1.pop(0))
    while g2:
        wesult.append(g2.pop(0))
    return result

d = [6, 8, 3, 9, 10, 1, 2, 4, 7, 5]
print(merge_sort(d))
```

```bash
# 1. 숫자 10개가 두 그룹으로 나뉘게 됨
g1 = [6, 8, 3, 9, 10] / g2 = [1, 2, 4, 7, 5]
# 2. 재귀호출로 각 그룹이 정렬됨
g1 = [3, 6, 8, 9, 10] / g2 = [1, 2, 4, 5, 7]
# 3. 두 그룹의 맨 앞 숫자 중 작은 것을 result에 추가
g1 = [3, 6, 8, 9, 10] / g2 = [2, 4, 5, 7] / result = [1]
g1 = [3, 6, 8, 9, 10] / g2 = [4, 5, 7] / result = [1, 2]
g1 = [6, 8, 9, 10] / g2 = [4, 5, 7] / result = [1, 2, 3]
g1 = [6, 8, 9, 10] / g2 = [5, 7] / result = [1, 2, 3, 4]
g1 = [6, 8, 9, 10] / g2 = [7] / result = [1, 2, 3, 4 ,5]
g1 = [8, 9, 10] / g2 = [7] / result = [1, 2, 3, 4, 5, 6]
g1 = [8, 9, 10] / g2 = [] / result = [1, 2, 3, 4, 5, 6, 7]
```

```bash
# 2. 재귀호출로 정렬되는 과정
```







## 탐색 알고리즘

### 1. 순차 탐색

> 찾고자하는 값을 데이터 배열의 첫 번째부터 하나씩 탐색하는 방법
> List, 연결 List 등 순차적으로 구현된 자료구조에서 유용함
> 데이터 별도로 조작할 필요가 없음

```python
num_list = [1,2,3,4,5]
num = 2
res = False # 기본은 False
for i in num_list: # num_list 내의 항목에 대해서
    if i == num: # 항목이 num과 일치하면
        res = True # res에 True
        break # 찾는 즉시 반복문에서 나감
print(res) # 끝까지 못 찾으면 기본 값 False 출력
```

* 정렬되지 않은 자료의 검색 과정
  1. 첫 원소부터 순서대로 검색대상과 키 값이 같은 원소가 있는지 비교하며 찾음
  2. 키 값이 동일한 원소를 찾으면 그 원소의 인덱스를 반환
  3. 자료구조의 마지막까지 검색 대상을 찾지 못하면 검색 실패

* 정렬된 자료의 검색 과정
  1. 자료가 오름차순으로 정렬된 상태에서 검색을 실시
  2. 자료를 순차적으로 검색하면서 키 값을 비교함
  3. 원소의 키 값이 검색 대상의 키 값보다 크면 원소가 없다는 것이므로 더이상 검색하지 않고 검색을 종료함



### 2. 이진 탐색

> 비교할 때마다 데이터의 양이 반씩 줄음 / 데이터가 정렬된 상태여야 됨
> 자료의 가운데 항목의 키 값과 비교하여 다음 검색의 위치를 결정, 검색
>
> 1. 자료의 중앙에 있는 원소 선택
>
> 2. 중앙 원소의 값과 찾고자 하는 목표 값을 비교
>
> 3. 목표값 < 중앙 원소 값 : 자료의 왼쪽 반에 대해서 새로 검색을 수행
>
>    목표값 > 중앙 원소 값 : 자료의 오른쪽 반에 대해서 새로 검색을 수행
>
> 4. 찾고자 하는 값을 찾을 때까지 반복
>
> * 삽입이나 삭제를 했을 때 List의 상태를 항상 정렬 상태로 유지해야 됨

* 간단한 이진 탐색의 예시

```python
def binarySearch(a, key):
    start = 0
    end = len(a) - 1
    while start <= end:
        middle = start + (end - start) // 2 # 중앙 원소 값
        if key == a[middle]: # 검색 성공
            return True
        elif key < a[middle]: # 목표값이 중앙 원소 값보다 작은 경우
            end = middle -1 # 끝을 중앙값 - 1 / 항목의 왼쪽 반
        else: # 큰 경우
            start = middle +1 # 시간을 중앙 값 + 1 # 항목의 오른쪽 반
    return False

num_list = [1, 2, 3, 4, 5, 9, 11, 17, 20]
key = 9
print(binarySearch(num_list, key)) # True
```

* 재귀 함수를 이용한 이진 탐색 1

```python
def binarySearch2(a, key, low, high):
    if low > high : # 검색 실패
        return False
    else:
        middle = (low + high) // 2
        if key == a[middle]: # 검색 성공
            return True
        elif key < a[middle]:
            return binarySearch2(a, key, low, middle-1)
        elif a[middle] < key:
            return binarySearch2(a, key, middle+1, high)

num_list = [1, 2, 3, 4, 5, 9, 11, 17, 20]
key = 9
print(binarySearch2(num_list, key, 0, len(num_list))) # True
```

* 재귀 함수를 이용한 이진 탐색 2

```python
def binary_search3(data, number = 0):
    mid = int(len(data)/2) # num_list의 중간 값
    if len(data)>1: # 처음 data의 길이가 1이상인지 (data list 안의 값이 2개 이상 인지)
        if data[mid] > number: # 목표 값이 중간 값보다 작은 경우
            binary_search3(data[:mid],number) # 중간 값의 앞 부분
        elif data[mid] < number: # 목표 값이 중간 값보다 큰 경우
            binary_search3(data[mid:],number) # 중간 값의 뒷 부분
        else:
            print("True")
    else: # data_list의 개수가 1개 이하이면 하나 남은 값과 ㅊ자는 값을 비교
        print(data[0]==number)

num_list = [1, 2, 3, 4, 5, 9, 11, 17, 20]
binary_search3(num_list, 9) # True
```





## 패턴 매칭

> 본문에서 특정한 문자열을 찾는 것



### 1. 고지식한 패턴 검색 알고리즘(Brute Force)

> 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 일일이 비교
>
> 1. 비교할 패턴과 원본 모두 첫 문자열부터 시작
>2. 일치하지 않을 경우 패턴 매칭 실패
> 3. 원본의 인덱스는 다음 시작점으로 이동, 패턴의 인덱스는 원점으로 돌아감

```python
p = 'is' # 찾을 패턴
t = 'This is a book~!' # 전체 텍스트
M = len(p) # 찾을 패턴의 길이
N = len(t) # 전체 텍스트의 길이

def BruteForec(p, t):
    i = 0 # t의 인덱스
    j = 0 # p의 인덱스
    while j < M and i < N:
        if t[i] != p[j]:
            i = i-j
            j = -1
        i += 1
        j += 1
    if j == M : return i-M # 검색 성공
    else: return -1 # 검색 실패
```



### 2. KMP 알고리즘

> 불일치가 발생한 앞 부분에 대해서는 다시 비교하지 않고 매칭을 수행
>
> 1. 패턴을 전처리하여 배열 next[M]을 구해서 잘못된 시작을 최소화함
>
>    next[M] : 불일치가 발생했을 경우 이동할 다음 위치
>
> 
>(패턴의 각 위치에 대해 매칭에 실패했을 때 돌아갈 곳을 준비해 둠)



### 3. 보이어-무어 알고리즘

> 오른쪽에서 왼쪽으로 비교, 
> 
> 패턴의 오른쪽 끝에 있는 문자가 불일치하고, 이 문자가 패턴 내에 존재하지 않는 경우
> 패턴의 길이 만큼 이동함
>
> 오른쪽 끝에 있는 문자가 불일치하고, 이 문자가 패턴 내에 존재할 경우
> 패턴에서 일치하는 문자를 찾아서 위치를 맞추어 줌

* 보이어-무어 알고리즘을 통한 패턴 탐색 예시

  `'a pattern matching algorithm'` 에서 `'rithm'`을 찾을 경우

  `rithm String`의 `skip`배열

|  m   |  h   |  t   |  i   |  r   | 다른 모든 문자 |
| :--: | :--: | :--: | :--: | :--: | :------------: |
|  0   |  1   |  2   |  3   |  4   |       5        |

		1. 'a pat' 5문자 -> 마지막 문자열이 t이므로 2칸 점프
​		2. 'patte' 5문자 -> 마지막 문자열이 e이므로 5칸 점프
​		3. 'rn ma' 5문자 -> 마지막 문자열이 a이므로 5칸 점프
​		... 'rithm' 5문자 -> 마지막 문자열과 패턴이 일치, 내부 문자열들 비교







## 완전 탐색

> 완전 검색 : 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열해보고 확인하는 기법
>
> * 모든 경우의 수를 테스트한 후, 최종 해법을 도출
>
> * 모든 경우의 수를 생성, 테스트하기 때문에 수행 속도는 느리지만 해답을 찾지 못할 확률이 적음
>

* Baby-Gin 게임 / 부분집합 문제 등 확인



#### 순열 : 서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것

* {1, 2, 3}을 사용해서 모든 순열을 프린트하는 경우

```bash
for i1 in range(1, 4):
    for i2 in range(1, 4):
        if i2 != i1:
            for i3 in range(1, 4):
                if i3 != i1 and i3 != i2:
                    print(i1, i2, i3)
```

```bash
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```







## 탐욕 알고리즘 (그리디 알고리즘)

> 최적 해를 구하기 위해 사용하는 근시안적인 방법
> 순간순간 가장 최적이라고 생각하는 것을 선택하는 방식
> 
> ※ 최적의 선택을 반복한 결과가 최적의 결과인 것은 보장할 수 없음
> ​	Ex) test = {7 : [30, 100], 13 : [5, 11]} 에서 가장 큰 값을 고를 때
> ​		최적의 결과는 7 + 100 이지만, 탐욕 알고리즘은 13 + 11이 됨
>
> 선택이 다음 선택과 전혀 무관한 값이고, 매 순간의 최적해가 문제에 대한 최적해인 경우 효과적

수행 과정

1. 해 선택 : 현재 상태에서 부분 문제의 최적 해를 구한 뒤, 이를 부분 해 집합에 추가
2. 실행 가능성 검사 : 새로운 부분 해 집합이 실행 가능한지를 확인 (문제의 제약 조건을 위반하지 않는지 검사)
3. 해 검사 : 새로운 부분 해 집합이 문제의 해가 되는지 확인, 아직 전체 문제의 해가 완성 X이면 해 선택부터 다시



#### 탐욕 알고리즘 적용 예시 - 동전 지불

해 선택 : 가장 단위가 큰 동전을 하나 골라 거스름돈에 추가
실행 가능성 검사 : 거스름돈이 손님에게 줘야할 액수를 초과하는 지 확인
​		초과한다면 마지막 동전을 빼고 해 선택으로 돌아가서 현재보다 한 단계 작은 단위의 동전을 추가
해 검사 : 거스름돈이 일치하는 지 확인, 모자라면 다시 해 선택으로 가서 반복



* 372원을 주려고 할 때, 1원, 10원, 50원, 100원 동전으로 주는 방법

```python
coins = [100, 50, 10, 1]
value = 362
dic = {}

for i in coins: # 각 동전의 크기를 key 값, value를 0으로 초기화
    dic[i] = 0

while value != 0:
    for coin in coins:
        if coin <= value:
            dic[coin] += 1
            value -= coin
            break

for key, val in dic.items():
    print('{0}원 동전 : {1}개'.format(key, val))
```

```bash
100원 동전 : 3개
50원 동전 : 1개
10원 동전 : 1개
1원 동전 : 2개
```





## 최단거리 알고리즘

> 한 지점에서 다른 지점까지의 최단거리 구하기
> 가장 적은 비용으로 해답에 도달하는 경로를 찾아내는 대부분의 문제
> ex. 네비게이션, 큐브 풀기, 미로탐색 등



## 회문 찾기

```python
def solution(s):
    que = []
    stack = []
    
    for x in s:
        if x.isalpha(): # 알파벳을 큐와 스택에 추가함
            que.append(x.lower())
            stack.append(x.lower())
    while que: # 큐에 문자가 남아있는 동안 반복
        if qu.pop(0) != st.pop(): # 큐에서 꺼낸 문자와 스택에서 꺼낸 문자 비교
            return False # 같지 않으면 회문이 아님
    return True

print(solution('Wow')) # True
print(solution('Madam,I`m Adam')) # True
print(solution('Madam,I am Adam')) # False
```



## 미로 찾기

```python
def solve_maze(maze, start, end):
    ex_rt = [] # 앞으로 이동 경로
    dn_rt = set() # 이미 이동한 꼭짓점

    ex_rt.append(start) # 시작 지점 입력
    dn_rt.add(start)

    while ex_rt:
        p = ex_rt.pop(0) # 앞으로 이동 경로에서 처리 대상을 가져옴
        v = p[-1] # 저장된 이동경로의 마지막 문자가 현재 처리할 꼭짓점
        if v == end: # 현재 꼭짓점이 도착점이면
            return p # 현재까지 저장된 전체 이동 경로
        for x in maze[v]: # 대상 꼭짓점에 연결된 꼭짓점 중에
            if x not in dn_rt: # 아직 이동한 적 없는 꼭짓점
                ex_rt.append(p + x) # 새 꼭짓점으로 추가하여, 이동경로에 추가
                dn_rt.add(x) # 이미 이동한 꼭짓점에도 추가
    return "빠져나오지 못하는 미로"


maze = {
    'a' : ['b'],
    'b' : ['a', 'f'],
    'c' : ['d'],
    'd' : ['c', 'h'],
    'e' : ['i'],
    'f' : ['b', 'g'],
    'g' : ['f', 'h'],
    'h' : ['d', 'g', 'l'],
    'i' : ['e', 'm'],
    'j' : ['f'],
    'k' : ['o'],
    'l' : ['h', 'p'],
    'm' : ['n', 'i'],
    'n' : ['o', 'm'],
    'o' : ['n', 'k', 'p'],
    'p' : ['l', 'o']
}

print(solve_maze(maze,'a', 'n'))
```

```bash
abfghlpon
```



## 최대 수익 구하기

```bash
stock = [10300, 9600, 9800, 8200, 7800, 8300, 9500, 9800, 10200, 9500]
```

### 1. 완전 탐색

```python
stock = [10300, 9600, 9800, 8200, 7800, 8300, 9500, 9800, 10200, 9500]
n = len(stock)
max_profit = 0

for i in range(n-1):
    for j in range(i+1, n):
        profit = stock[j] - stock[i]
        if profit > max_profit:
            max_profit = profit

print(max_profit)
```



### 2. 한번만 반복하기

> 가장 비싼 날 (= 파는 날)을 기준으로 가장 저렴한 가격만 알면 최대 이익 계산가능

```python
stock = [10300, 9600, 9800, 8200, 7800, 8300, 9500, 9800, 10200, 9500]

n = len(stock)
max_profit = 0
min_price = stock[0]

for i in range(1, n):
    profit = stock[i] - min_price # 지금까지 최솟값에 주식을 사서 i 날에 파는 수익
    if profit > max_profit:
        max_profit = profit
    if stock[i] < min_price:
        min_price = stock[i]
        
print(max_profit)
```

