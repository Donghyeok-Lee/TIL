# Data_Structure

> 데이터를 저장하고, 관리하기 위해 사용하는 구조
>
> 데이터의 효율적인 접근 및 조작을 가능하게 해주는 저장 및 관리 방식

## 자료 구조의 연산 시간 복잡도

* 점근적 상한 - 최악의 경우 (Big-O)

* 분할 상환 분석 (Amortized Analysis)

    * 최악의 경우가 아닌 평균을 통해 계산하는 방법

        같은 동작은 n번 했을 때 드는 시간이 X라면 X / n으로 계산



## 기본 자료 구조

### 배열

> * 크기가 고정되어 있음
> * 같은 타입의 데이터만 담을 수 있음
> * 데이터가 메모리에 연속적으로 저장됨

* **주요 연산의 시간 복잡도**
    * 인덱스를 이용한 접근 : O(1)
    * 배열 탐색 : O(n) / 0번 인덱스부터 선형 탐색

* **정적 배열**
  
    * 크기가 고정되어 있는 일반적인 배열
    
    * 처음 선언 시 배열을 위한 메모리 주소를 할당함
    
    * 실제 데이터보다 큰 크기의 배열을 선언하면, 메모리가 낭비될 수 있음
    
    * 왜 삽입과 삭제가 불가능한가?
    
        * 삽입의 경우
    
            * 배열을 선언할 때 크기를 지정해 줌 - 추가할 경우 추가적인 공간이 필요...
    
        * 삭제의 경우
    
            * 특정 데이터의 뒷 부분 데이터를 앞으로 당기며 지울 수는 있으나,
    
                마지막 데이터에 null이나 None을 넣을 수 없음... (타입이 동일해야 됨)
* **동적 배열**

    * 크기가 변하는 배열

    * 내부적으로는 정적 배열로 만들어져있지만, 크기를 상황에 맞게 조절함

        (Ex. 필요할 때 배열의 크기를 2배로 만드는 등)

    * 동적 배열 연산의 시간 복잡도

        * 추가 연산(Append)

            1. 할당된 공간에 여유 공간이 있을 때 - O(1)

            2. 할당된 공간이 가득 차 있을 경우 - O(n)

                새로운 공간을 할당하고, 내부 값을 전부 복사한 뒤에 새로운 값을 추가해야 됨

            * 분할 상환 분석을 할 경우, O(1)

        * 삽입 연산(Insert)

            1. 할당된 공간에 여유 공간이 있을 때
                * 최선의 경우 (가장 뒤에 데이터 삽입) : O(1)
                * 최악의 경우 (가장 앞에 데이터 삽입) : O(n)
            2. 할당된 공간이 가득 차 있을 경우 - O(n)

        * 삭제 연산(Delete)

            * 최선의 경우 (가장 뒤에 데이터 삭제) - O(1)
                * 단, 낭비되는 공간이 너무 많은 경우, 동적 배열에 할당된 공간을 줄이기 위해 O(n)이 걸리기도 함
                * 분할 상환 분석 시 O(1)
            * 최악의 경우 (가장 앞에 데이터 삭제) - O(n)



### 링크드 리스트

> * 배열, 동적 배열처럼 데이터를 순서대로 저장해준다.
> * 요소를 계속 추가할 수 있다.
> * 구현 방식이 동적 배열보다 조금 복잡합
> * 상황에 따라 링크드 리스트, 동적 배열을 판단해서 사용
>
> 노드라는 단위에 데이터를 저장, 노드를 순서대로 연결해서 만든 자료구조

* **싱글리 링크드 리스트**
    * 노드에 데이터와 다음 노드에 대한 레퍼런스를 저장
    * 시간 복잡도
        * 접근 연산 (특정 위치에 있는 노드를 리턴하는 연산) - O(n)
        * 탐색 연산 (선형 탐색) - O(n)
        * 삽입 연산 - O(1) / 삭제 연산 - O(1)
            * 삽입, 삭제할 인덱스 주변의 노드들에 연결된 레퍼런스만 수정하면 됨!
            * 단, 현실적으로는 O(n+1) / 접근도 해야 됨
            * 가장 앞에 데이터 삽입 / 삭제 - O(1)
            * 가장 뒤에 데이터 삽입 - O(1) / 삭제 - O(n) // 가장 뒤를 삭제하기 위해서는 그 앞에 접근해야 됨
* **더블리 링크드 리스트**
    * 각 노드가 데이터와 다음 노드, 이전 노드에 대한 레퍼런스를 저장
    
    * 시간 복잡도
        * 대부분 싱글리 링크드 리스트와 동일
        * 가장 뒤에 데이터를 삭제할 경우 O(1)
        *  **tail 노드를 많이 삭제해야 된다면, 더 효율적**
        * 단, 메모리를 더 많이 사용 (이전에 대한 레퍼런스도 저장해야 됨)
        
    * 구현 예시
    
        ```python
        class Node:
         """링크드 리스트의 노드 클래스"""
         def __init__(self, data):
             self.data = data
             self.next = None  # 다음 노드에 대한 레퍼런스
             self.prev = None  # 이전 노드에 대한 레퍼런스
             
        class LinkedList:
         """링크드 리스트 클래스"""
         def __init__(self):
             self.head = None
             self.tail = None
             
         def find_node_at(self, index):
             """링크드 리스트 접근 연산 메소드. 파라미터 인덱스는 항상 있다고 가정"""
             iterator = self.head
             for _ in range(index):
                 iterator = iterator.next
             return iterator
        
         def append(self, data):
             """링크드 리스트 추가 연산 메소드"""
             new_node = Node(data)
        
             if self.head is None:
                 self.head = new_node
                 self.tail = new_node
             else:
                 self.tail.next = new_node
                 new_node.prev = self.tail
                 self.tail = new_node
        
        def insert_after(self, previous_node, data):
            """더블리 링크드 리스트 삽입 연산 메소드"""
            new_node = Node(data)
        
            if previous_node == self.tail:
                new_node.prev = previous_node
                previous_node.next = new_node
                self.tail = new_node
            else:
                new_node.prev = previous_node
                new_node.next = previous_node.next
                previous_node.next.prev = new_node
                previous_node.next = new_node
                
        def delete(self, node_to_delete):
            """더블리 링크드 리스트 삭제 연산 메소드"""
            if (node_to_delete == self.head) and (node_to_delete == self.tail):
                self.head = None
                self.tail = None
            elif node_to_delete == self.head:
                self.head = node_to_delete.next
                node_to_delete.next.prev = None
            elif node_to_delete == self.tail:
                self.tail = node_to_delete.prev
                node_to_delete.prev.next = None
            else:
                node_to_delete.prev.next = node_to_delete.next
                node_to_delete.next.prev = node_to_delete.prev
            return node_to_delete.data
        ```
    
        

### 해시 테이블

> key에 대응하는 value가 있는 key-value 데이터

* **Direct Access Table**

    * 효율적으로 key-value 쌍을 저장하고 가져올 수 있다. - 낭비되는 공간이 많음

* **해시 테이블**

    * 해시 함수와 배열을 같이 사용함
    * 키를 해시 함수에 넣어서 리턴된 값을 인덱스로 사용함
    * **해시 함수**
        * 특정 값을 원하는 범위의 자연수로 바꿔주는 함수
        * 키가 아무리 커도 항상 원하는 범위 자연수로 바꿀 수 있음

    1. 고정된 크기의 배열을 만든다.
    2. 해시 함수를 이용해서 key를 원하는 범위의 자연수로 바꾼다.
    3. 해시 함수 결과 값 인덱스에 key-value 값을 저장

* 해시 테이블 충돌

    * 서로 다른 key를 해시함수에 넣었을 때 같은 숫자가 나오는 경우 - 충돌(Collistion)
    * 충돌이 일어난 경우 해결하는 방법 - Chaining / Open Adressing 등
    * **Chaining**
        * 링크드 리스트 클래스를 이용해서 저장
        * 최악의 경우 모든 key-value 데이터 쌍이 한 링크드 리스트에 저장될 수 있음
    * **Open Adressing**
        * 다른 비어있는 인덱스를 찾아서 데이터를 저장
        * 선형 탐사, 제곱 탐사 등을 통해 비어있는 인덱스를 찾음



### 추상자료형

> 자료 구조를 추상화 / 데이터를 저장, 사용할 때 기능만 생각함

* 추상 자료형 vs 자료구조 비교
    * 추상 자료형 - 리스트
        * 데이터간 순서 관계를 유지할 수 있다.
            * 접근 연산 : 특정 위치에 있는 데이터를 가져오거나 수정한다.
            * 탐색 연산 : 특정 조건을 만족하는 데이터를 찾는다.
            * 삽입 연산 : 특정 위치에 데이터를 저장한다.
            * 삭제 연산 : 특정 위치에 있는 데이터를 지운다.
    * 자료구조 - 동적 배열
        * 데이터를 메모리에 순서대로 그리고 연속적으로 저장한다.
            * 접근 연산 : 인덱스 주소를 한 번에 계산해서 메모리에 접근한다.
            * 탐색 연산 : 가장 앞 인덱스부터 선형적으로 모든 데이터를 확인한다.
            * 삽입 연산 : 인덱스 뒤 데이터를 한 칸씩 뒤로 밀고, 데이터를 저장한다.
            * 삭제 연산 : 데이터를 지우고 뒤 인덱스들을 하나씩 앞으로 옮겨서 저장한다.
        * 정확히 데이터를 어떻게 저장하고, 데이터 간 관계를 어떻게 유지할지,
            각 연산을 구체적으로 어떻게 할지를 묶어놓은 개념
    * **추상 자료형 리스트는 동적 배열 혹은 링크드 리스트로 구현할 수 있다!!**
        * 인덱스에 대한 접근을 자주하는 경우 동적 배열로 구현 - 기본적으로 python이 사용하는 방식
        * 요소의 추가, 삭제가 빈번히 일어날 경우 링크드 리스트로 구현하는 것이 유리 (deque)
* 큐 (Queue)
    * **선입 선출 구조**(FIFO - First In First Out) / 앞에서만 데이터를 삭제하고, 뒤에만 데이터 추가
* 스택 (Stack)
    * **후입 선출 구조**(Last In First Out) / 가장 마지막에 들어온 데이터가 가장 먼저 삭제됨



## Python의 자료형

> 파이썬의 자료 저장 방식 (레퍼런스 저장) - 깊은 복사와 얕은 복사 등

### List

* 레퍼런스를 저장함 / 데이터가 연속적인 공간에 있을 수도 있고, 아닐 수도 있음
* 자료들의 크기가 상관없기 때문에, 서로 다른 타입의 데이터를 저장 가능
* append, remove, pop 등을 이용해서 항목을 추가 / 제거 가능
* 동적 배열을 기반으로 생성

### Set

* 데이터간 순서 관계를 약속하지 않음
    * 삽입 : 데이터를 저장할 수 있다. (중복 데이터 X)
    * 탐색 : 데이터가 저장됐는지 확인할 수 있다.
    * 삭제 : 저장한 데이터를 지울 수 있다.

### Dictionary

* 데이터간 순서 관계를 약속하지 않음
    * key - value 데이터 쌍 삽입
    * key를 이용한 데이터 탐색
    * key를 이용한 데이터 삭제



### 파이썬 자료형 선택하기

* 자신이 데이터에 하고 싶은 연산들이 뭐가 있고 얼마나 걸릴지에 대해서 잘 생각해야 됨

    (리스트와 세트 모두 데이터를 저장할 수 있고, 저장한 데이터를 탐색할 수 있는 자료형이지만,

    근데 리스트는 동적 배열, 세트는 해시 테이블로 구현 - 시간 복잡도 차이 존재)





## 트리

### 힙 (Heap)

### 이진 탐색 트리 (Binary Search Tree)



## 그래프